template <class T>
void dlist<T>::front_insert(const T &other){
    if(head == NULL){
        head = tail = new dnode<T>(other);
        return;
    }
    dnode<T> *insert_ptr = head;
    head = new dnode<T>(other, NULL, insert_ptr);
    insert_ptr -> set_previous(head);
}

template <class T>
void dlist<T>::rear_insert(const T& other){
    if(head == NULL){
        head = tail = new dnode<T>(other);
        return;
    }

    dnode<T>* insert_ptr = tail;
    tail = new dnode<T>(other, insert_ptr);
    insert_ptr -> set_next(tail);
}

template <class T>
void dlist<T>::front_remove(){
    dnode<T> *rm_ptr = head;
    if (head == NULL) return;

    else if(size() == 1){ // one item list 
        tail = head = NULL;
    }
    else{
        head = head -> next();
        head -> set_previous(NULL);
    }
    delete rm_ptr;
}

template <class T>
void dlist<T>::rear_remove(){
    dnode<T> *rm_ptr = tail;
    if (tail == NULL) return;
  
    else if(size() == 1){
        tail = head = NULL;
    }
    else{
        tail = tail -> previous();
        tail -> set_next(NULL);
    }
    delete rm_ptr;
}

template <class T>
void dlist<T>::show(){
    dnode<T> *cursor;

    for (cursor = head; cursor != NULL; cursor = cursor -> next()){
        cout << cursor -> data() << endl;
    }
}

template <class T>
void dlist<T>::reverse_show(){
    dnode<T> *cursor;

    for(cursor = tail; cursor != NULL; cursor = cursor -> previous()){
        cout << cursor -> data() << endl;
    }
}

template <class T>
int dlist<T>::size(){
    dnode<T> *cursor;
    int i = 0;
    for(cursor = head; cursor != NULL; cursor = cursor -> next())
        ++i;
    return i;
}

/* 
template <class T>
dlist<T>::~dlist(){
    dnode<T> * rmptr;
    while(head != NULL){
        rmptr = head;
        head = head -> next();
        delete rmptr;
    }
    tail = NULL;
}

*/

/*
template <class T>
dlist<T>::dlist(const dlist<T>& source){
    if(source.head == NULL){ // check for empty list
        head = tail = NULL;
        return;
    }


remember the implementation is in notebook


}
/*

/*
template <class T>
void dlist<T>::operator =(const dlist<T>& source){

 remember implementation in notebook 
}
*/